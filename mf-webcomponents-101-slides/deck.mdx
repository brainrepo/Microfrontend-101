import { themes } from 'mdx-deck'
import { Split } from 'mdx-deck'
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { github, vsDark } from "@code-surfer/themes";


export const theme = {
    ...themes.future
}




# Webcomponents

---

<Split>

<img style={{width: '100%'}} src="https://miro.medium.com/max/3840/1*4cFhtuq6zRDqJ6p4s2pQ6g.jpeg" />

Quale è il motivo per cui usiamo i frameworks?

</Split>

---

## pros

- Divide et impera
- approccio a componenti

## cons

- mondo frammentato e disorientante
- scontri su quale è il framework migliore

---

Esigenza dei componenti la vediamo <br/>
dall'epoca di jquery (plugins) <br/>
o dall'era i bootstrap (css components) 

---

# Cosa sono i componenti

- insieme di specifiche standard per la creazione di elementi HTML personalizzati e riutilizzabili
- Mattoncini del web moderno
- tecnologia risale al 2011, e il primo Working Draft del W3C è del 2012
- Elementi riusabili
- Creabili in modo nativo, spesso eliminano il bisogno di frameworks

---


<Split>

<img style={{width: '100%'}} src="https://i2.wp.com/josephmuciraexclusives.com/wp-content/uploads/2020/01/AMP-Plugin-for-WordPress.jpg?fit=1000%2C500&ssl=1" />

Anche il progetto AMP li usa

</Split>

---

<Split>

<img style={{width: '100%'}} src="https://www.genitoriorganizzati.it/wp-content/uploads/2014/10/candelelego.jpg" />

Si basano su 3 elementi principali:

- custom elements
- templates (non necessario)
- shadow dom (non necessario)

</Split>

---

# Custom elements

---

<Split>

<img style={{width: '100%'}} src="https://images.thecarconnection.com/med/delorean-dmc-12-time-machine-from-back-to-the-future_100367456_m.jpg" />

Insieme di API JavaScript per la creazione<br /> di elementi del DOM

- Personalizzati 
- associati ad uno specifico tag HTML

</Split>

---

Permette la creazione di elementi html custom:

Viviamo in un epoca di web reattivo 

Ui sempre piu articolate e complesse

- Metodo basato sui web Standard 
- Html è dichiarativo, portabile e ben supportato
- Possiamo incapsulare i superpoteri (comportamenti in JS)

---

<Split>

<img style={{width: '100%'}} src="https://images-na.ssl-images-amazon.com/images/I/51wUg1uxfaL._AC_SY450_.jpg" />

Poter inserire i comportamenti ci permette di dare vita all'html,
che ne definisce solo il lato strutturale

</Split>

---



<Split>

<img style={{width: '100%', height: '100%'}} src="data:image/png;base64,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" />


Puoi usare react e angular per tutto ma al posto di usare div o span 

usi i custom webcomponents

I Frameworks agiscono colla tra i componenti. 
Uso dello stato del routing

</Split>


---

## I vantaggi

- meno codice
- codice modulare
- codice riusabile

---

## I requisiti


- Usare trattino nel nome, i nomi senza trattino sono riservati ai tag nativi se non lo si fa restituisce errore unknown element (compatibilita per aggiunta di standard html tags futuri)
- Non puoi registrare i tag piu di una volta altrimenti incappi in una dom exception
- Non è possibile usare il selfclosing riservato solo ad alcuni elements nativi (neanche tutti)

---


<Split>

Al LAVORO!

<img style={{width: '100%', height: '100%'}} src="https://media.giphy.com/media/hOzfvZynn9AK4/giphy.gif" />

</Split>

---


<CodeSurferColumns themes={[github, vsDark]}>

<Step subtitle="Custom element base">

```html title="html" 
  
<html>

    <head>
        <title>Esercizi sui webcomponents</title>
    </head>

    <body>
        <basic-component>Componente Basic</basic-component>
        <script src="components.js"></script>
    </body>
</html>
```

```js title="js" 
/**
* Esempio di webcomponent che estende un html element
*/
class BasicComponent extends HTMLElement {
   constructor() {
       /**
        * Chiama il costruttore del parent ereditando 
        * quindi tutte le abilità a lavorare
        * sul dom
        */
       super();
   }
}

customElements.define('basic-component', BasicComponent);

```

</Step>

</CodeSurferColumns>


---

# Creazione di un custom element

Usa la globale `window.customElements` per definire nuovi elementi
e indicare al browser come reagire in merito al nuovo tag

---


`customElements.define('basic-component', BasicComponent);`

prende il nome del tag e la classe che estende la classe base HTMLElement

---

La classe che implementa il nuovo elemento deve essere es6 / es 2015 

e deve estendere HTMLElement, in questo modo eredita la dom API

---

<CodeSurferColumns themes={[github, vsDark]}>

<Step title="Ciclo di vita di un webcomponent / costruttore">

<div>

- viene chiamato quando l'elemento e creato o upgradato
- puoi iserire piu custom element nella pagina e non chiamare il customelement.define(...) questi verranno trattarti come unknown tags verranno poi reidratati alla chiamarta (element upgrades)
- usato per definire lo stato iniziale, impostare event listeners, creare lo shadow dom

</div>

```js title="js" 
class BasicComponent extends HTMLElement {
   constructor() {
       super();
   }
}
```

</Step>

<Step title="Ciclo di vita di un webcomponent / connected callback">

<div>

- ogni volta che un elemento viene inserito nel nostro codice html
- usato per fare il fetch di risorse remote o per chiamare funzioni di rendering

</div>


```js 10:13 title="js" 

export default class CustomParagraph extends HTMLParagraphElement{
    constructor(){
        super();
    }

    static get observedAttributes() {
        return ['c'];
    }

    connectedCallback() {
        this.updateStyle("red");
        this.setAttribute('c', 'red')
    }

    disconnectedCallback() {
        console.log("Elemento rimosso dalla pagina")
    }

    attributeChangedCallback(name, oldVal, newVal) {
        this.updateStyle(newVal);
    }

    updateStyle(color) {
        this.style.color = color;
    }
}
```

</Step>


<Step title="Ciclo di vita di un webcomponent / disconnected callback">

<div>

- ogni volta che un elemento viene rimosso dal dom
- usare per chiudere connessioni come indexeddb o killare event listener
- Attenzione, non viene chiamato alla chiusura del tab del browser!

</div>


```js 15:17 title="js" 

export default class CustomParagraph extends HTMLParagraphElement{
    constructor(){
        super();
    }

    static get observedAttributes() {
        return ['c'];
    }

    connectedCallback() {
        this.updateStyle("red");
        this.setAttribute('c', 'red')
    }

    disconnectedCallback() {
        console.log("Elemento rimosso dalla pagina")
    }

    attributeChangedCallback(name, oldVal, newVal) {
        this.updateStyle(newVal);
    }

    updateStyle(color) {
        this.style.color = color;
    }
}
```

</Step>


<Step title="Ciclo di vita di un webcomponent / attributeChangedCallback">

<div>

metodo chiamato quando un "observed attribute" subisce un certo cambiamento

</div>


```js 7:9,19:25 title="js"

export default class CustomParagraph extends HTMLParagraphElement{
    constructor(){
        super();
    }

    static get observedAttributes() {
        return ['c'];
    }

    connectedCallback() {
        this.updateStyle("red");
        this.setAttribute('c', 'red')
    }

    disconnectedCallback() {
        console.log("Elemento rimosso dalla pagina")
    }

    attributeChangedCallback(name, oldVal, newVal) {
        this.updateStyle(newVal);
    }

    updateStyle(color) {
        this.style.color = color;
    }
}

```

</Step>

</CodeSurferColumns>

---

# Proprieta e attributi

Pratica comune è quella di riflettere le proprieta negli attributi per tenere il dom in sync con lo stato

**Consiglio:** accettare dati solo primitivi negli attributi e proprieta. Se abbiamo bisogno di usare props composte non riflettere rich-data negli attributi perché **perdono identità...** es. con json string si perdono i riferimenti ad altri oggetti contenuti

---




<Split>

<img style={{width: '100%', height: '100%'}} src="https://media.giphy.com/media/H4buZ6PLgwsKjA9hlO/giphy.gif" />

# Shadow DOM

API JavaScript che consentono di gestire un DOM specifico per un componente, indipendente dal DOM della pagina Web, realizzando il meccanismo di incapsulamento


</Split>

---


<Split>

Contiene lo sporco (nasconde html e css). <br /><br />
permette a un element stesso di renderizzare e stilare un blocco dom in modo separato dalla pagina


<img style={{width: '100%', height: '100%'}} src="https://images-na.ssl-images-amazon.com/images/I/91GNwajiVKL._AC_SX450_.jpg" />

</Split>

---

# E' possibile incapsulare gli eventi

- la migliore soluzione è quella di incapsulare tutti gli eventi che avvengono nello shadow dom e rimapparli

---

Esplorare lo shadow dom 

---

<CodeSurferColumns themes={[github, vsDark]}>

<Step title="Shadow dom in un custom element">


Creo lo shadow root


```js 6 title="js"

export default class ComponentWithShadowDom extends HTMLElement{
    constructor(){
        super();

        var shadow = this.attachShadow({mode: 'open'});

      
        var wrapper = document.createElement('span');
        wrapper.setAttribute('class','wrapper');
        var info = document.createElement('span');
        info.setAttribute('class','info');

        var text = this.getAttribute('text');
        info.textContent = text;

        var style = document.createElement('style');

        style.textContent = `.wrapper{
            color: red;
            font-weight: bold;
            border: 1px solid red;
        }`

        // attach the created elements to the shadow dom
        shadow.appendChild(style);
        shadow.appendChild(wrapper);
        wrapper.appendChild(info);

    }
    
}

```

</Step>

<Step title="Shadow dom in un custom element">


Ci attacco tutti gli elementi necessari


```js 9:15 title="js"

export default class ComponentWithShadowDom extends HTMLElement{
    constructor(){
        super();

        var shadow = this.attachShadow({mode: 'open'});

      
        var wrapper = document.createElement('span');
        wrapper.setAttribute('class','wrapper');
        var info = document.createElement('span');
        info.setAttribute('class','info');

        var text = this.getAttribute('text');
        info.textContent = text;

        var style = document.createElement('style');

        style.textContent = `.wrapper{
            color: red;
            font-weight: bold;
            border: 1px solid red;
        }`

        // attach the created elements to the shadow dom
        shadow.appendChild(style);
        shadow.appendChild(wrapper);
        wrapper.appendChild(info);

    }
    
}

```

</Step>

<Step title="Shadow dom in un custom element">


Ci attacco lo stile


```js 16:23 title="js"

export default class ComponentWithShadowDom extends HTMLElement{
    constructor(){
        super();

        var shadow = this.attachShadow({mode: 'open'});

      
        var wrapper = document.createElement('span');
        wrapper.setAttribute('class','wrapper');
        var info = document.createElement('span');
        info.setAttribute('class','info');

        var text = this.getAttribute('text');
        info.textContent = text;

        var style = document.createElement('style');

        style.textContent = `.wrapper{
            color: red;
            font-weight: bold;
            border: 1px solid red;
        }`

        // attach the created elements to the shadow dom
        shadow.appendChild(style);
        shadow.appendChild(wrapper);
        wrapper.appendChild(info);

    }
    
}

```

</Step>



<Step title="Shadow dom in un custom element">



Appendo tutto allo shadow dom




```js 25:28 title="js"

export default class ComponentWithShadowDom extends HTMLElement{
    constructor(){
        super();

        var shadow = this.attachShadow({mode: 'open'});

      
        var wrapper = document.createElement('span');
        wrapper.setAttribute('class','wrapper');
        var info = document.createElement('span');
        info.setAttribute('class','info');

        var text = this.getAttribute('text');
        info.textContent = text;

        var style = document.createElement('style');

        style.textContent = `.wrapper{
            color: red;
            font-weight: bold;
            border: 1px solid red;
        }`

        // attach the created elements to the shadow dom
        shadow.appendChild(style);
        shadow.appendChild(wrapper);
        wrapper.appendChild(info);

    }
    
}

```

</Step>

</CodeSurferColumns>

---

# Templates

---


<Split>

<img style={{width: '100%', height: '100%'}} src="https://media.giphy.com/media/3oKIPj5Xk0P8J574wU/giphy.gif" />

consente di definire porzioni di markup che non viene interpretato al caricamento della pagina Web, ma che viene istanziato a runtime

Usato per non dover scrivere l'html in modo programmatico

- tag template dormiente by default
- se nel template ho uno script viene eseguito all'instanziazione
- non hanno un concetto di incapuslamento come lo shadow dom

</Split>

---

<CodeSurferColumns themes={[github, vsDark]}>

<Step title="Componente che usa lo shadow DOM">

<div>
    Mi catturo il contenuto del template
</div>

```js 5:6 title="js" 

class WithTemplate extends HTMLElement {
    constructor() {
      super();
      let template = document.getElementById('component-with-template');
      let templateContent = template.content;

      const shadowRoot = this.attachShadow({mode: 'open'})
        .appendChild(templateContent.cloneNode(true));
    }
  }

```

</Step>

<Step title="Componente che usa lo shadow DOM">

<div>
    Lo appendo allo shadow dom
</div>

```js 8:9 title="js" 

class WithTemplate extends HTMLElement {
    constructor() {
      super();
      let template = document.getElementById('component-with-template');
      let templateContent = template.content;

      const shadowRoot = this.attachShadow({mode: 'open'})
        .appendChild(templateContent.cloneNode(true));
    }
  }

```

</Step>

<Step title="Componente che usa lo shadow DOM">

<div>
    Il codice del template, che incapsula anche uno stile
</div>

```js title="html" 

    <template id="component-with-template">
        <style>
            p {
                color: white;
                background-color: #666;
                padding: 5px;
            }
        </style>
        <p>Component with template</p>
    </template>


```

</Step>

</CodeSurferColumns>